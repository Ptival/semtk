/**
 ** Copyright 2016 General Electric Company
 **
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** 
 **     http://www.apache.org/licenses/LICENSE-2.0
 ** 
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */


package com.ge.research.semtk.edc;

import java.io.File;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.UUID;

import org.json.simple.JSONObject;

import com.ge.research.semtk.auth.ThreadAuthenticator;
import com.ge.research.semtk.belmont.AutoGeneratedQueryTypes;
import com.ge.research.semtk.belmont.NodeGroup;
import com.ge.research.semtk.belmont.PropertyItem;
import com.ge.research.semtk.belmont.ValueConstraint;
import com.ge.research.semtk.load.utility.SparqlGraphJson;
import com.ge.research.semtk.resultSet.Table;
import com.ge.research.semtk.resultSet.TableResultSet;
import com.ge.research.semtk.sparqlX.SparqlEndpointInterface;
import com.ge.research.semtk.sparqlX.SparqlResultTypes;
import com.ge.research.semtk.sparqlX.SparqlToXUtils;
import com.ge.research.semtk.utility.LocalLogger;
import com.ge.research.semtk.utility.Utility;

/**
 *   JobTracker instantiates a connection to the tripleStore
 *   and uses it to fulfill requests for info about a jobId.
 *
 */
public class JobTracker {
	JobEndpointProperties prop = null;
	SparqlEndpointInterface endpoint = null;
	
	public JobTracker (JobEndpointProperties edc_prop) throws Exception {
		this.prop = edc_prop;
		this.endpoint = SparqlEndpointInterface.getInstance(	this.prop.getJobEndpointType(),
																this.prop.getJobEndpointServerUrl(), 
																this.prop.getJobEndpointDataset(),
																this.prop.getJobEndpointUsername(),
																this.prop.getJobEndpointPassword());
	}
	
	public static String generateJobId() {
		return UUID.randomUUID().toString();
	}
	
	private String getJobUri(String jobId) {
		return "http://research.ge.com/semtk/services/data/Job_" + SparqlToXUtils.safeSparqlString(jobId);
	}
	private String getFileUri(String fileId) {
		return "http://research.ge.com/semtk/services/data/File_" + SparqlToXUtils.safeSparqlString(fileId);
	}

	/**
	 * Return percent complete as a string, or throw exception
	 * @param jobId
	 * @return
	 * @throws Exception if jobId doesn't exist or job has no percentComplete
	 */
	public int getJobPercentComplete(String jobId) throws Exception {	    
		   
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	select distinct ?Job ?percentComplete where {  \n" +            // PEC: added ?Job for debugging double percentComplete problem 9/13/2017
	    	"	   ?Job a job:Job.  \n" +
	    	"	   ?Job job:id '%s'^^XMLSchema:string .  \n" +
	    	"	   ?Job job:percentComplete ?percentComplete .  \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

	    endpoint.executeQuery(query, SparqlResultTypes.TABLE);
	    
	    String trList[] = endpoint.getStringResultsColumn("percentComplete");
	    
	    if (trList.length > 1) {
	    	LocalLogger.logToStdErr("getJobPercentComplete found multiple percentComplete entries:\n%s" + endpoint.getResponse());
	    	throw new Exception(String.format("Job %s has %d percentComplete entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find percent complete for Job %s",  jobId));
	    	}
	    } else {
	    	int ret = Integer.parseInt(trList[0]);
	    	
	    	if (ret < 0 || ret > 100) {
	    		throw new Exception(String.format("Trouble parsing percent complete of job %s into an int 0-100.  Value = '%s'", jobId, trList[0]));
	    	}
		    return ret;
	    }
	}
	
	/**
	 * Set percentComplete for a job, 
	 *   creating the job if it doesn't exist.
	 * @param jobId
	 * @param percentComplete 0-99
	 * @throws Exception
	 */
	
	public void setJobPercentComplete(String jobId, int percentComplete) throws Exception {	    
		setJobPercentComplete(jobId, percentComplete, "");
	}
	
	public void setJobPercentComplete(String jobId, int percentComplete, String message) throws Exception {	    
	   
	    if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	    
	    if (percentComplete < 0) { 
	    	throw new Exception (String.format("Can't set job %s percent complete to negative percent complete value: %d", jobId, percentComplete));
	    }
	    if (percentComplete > 99) { 
	    	throw new Exception (String.format("Can't set job %s percent complete to 100%% or above.  Set success or failure instead.", jobId));
	    }

	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "DELETE {\n" +
	        "   ?Job job:percentComplete ?percentComplete .\n" +
	        "   ?Job job:status ?status." +
	        "   ?Job job:statusMessage ?statusMessage." +
	        "} \n" +
	        "INSERT {\n" +
	        "   ?Job job:percentComplete '%d'^^XMLSchema:integer. \n" +
	        "   ?Job job:status job:InProgress. \n" +
	        "   ?Job job:statusMessage '%s'^^XMLSchema:string." +
	        "} \n" +
	        "where { \n" +
	        "   ?Job a job:Job. \n" +
	        "   ?Job job:id '%s'^^XMLSchema:string. \n" +
	        "   optional {?Job job:percentComplete ?percentComplete.} \n" +
	        "   optional {?Job job:status ?status.} \n" +
	        "   optional {?Job job:statusMessage ?statusMessage.}" +
	        "}",
	    	percentComplete, SparqlToXUtils.safeSparqlString(message), SparqlToXUtils.safeSparqlString(jobId));
	 	// LocalLogger.logToStdErr(query);
	    try {
	    	endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.getMessage());
	    }
	}
	
	/**
	 * Set job to a status other than Success,
	 *    creating job if it doesn't exist
	 * @param jobId
	 * @param statusMessage
	 */
	public void setJobFailure(String jobId, String statusMessage) throws Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	  
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "DELETE {\n" +
			"   ?Job job:percentComplete ?percentComplete . \n" +
			"   ?Job job:statusMessage ?statusMessage . \n" +
	        "   ?Job job:status ?status." +
	        "} \n" +
	        "INSERT {\n" +
			"   ?Job job:percentComplete '100'^^XMLSchema:integer.  \n" +
	        "   ?Job job:statusMessage '%s'^^XMLSchema:string. \n" +
	        "   ?Job job:status job:Failure. \n" +
	        "} \n" +
	        "where { \n" +
	        "   ?Job a job:Job. \n" +
	        "   ?Job job:id '%s'^^XMLSchema:string . \n" +
			"   optional {?Job job:percentComplete ?percentComplete .} \n" +
	        "   optional {?Job job:statusMessage ?statusMessage.} \n" +
	        "   optional {?Job job:status ?status.} \n" +
	        "}",
	        
	        SparqlToXUtils.safeSparqlString(statusMessage), SparqlToXUtils.safeSparqlString(jobId));
	 	// LocalLogger.logToStdErr(query);
	    try {
	    	endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.getMessage());
	    }
	}
	
	/**
	 * Get job status local fragment as a string
	 * @param jobId
	 * @return
	 * @throws Exception if jobId can't be found or has not status
	 */
	public String getJobStatus(String jobId) throws Exception {
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
				"	  \n" +
				"	select distinct ?status where {  \n" +
				"	   ?Job a job:Job.  \n" +
				"	   ?Job job:id '%s'^^XMLSchema:string .  \n" +
				"	   ?Job job:status ?status .  \n" +
				"	}",
				SparqlToXUtils.safeSparqlString(jobId));

		endpoint.executeQuery(query, SparqlResultTypes.TABLE);

		String trList[] = endpoint.getStringResultsColumn("status");

		if (trList.length > 1) {
			throw new Exception(String.format("Job %s has %d status entries.  Expecting 1.", jobId, trList.length));
		} else if (trList.length == 0) {
			if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find status for Job %s",  jobId));
	    	}
		} else {
			return trList[0].split("#")[1];
		}
	}
	
	/**
	 * Get job status message
	 * @param jobId
	 * @return message string
	 * @throws Exception if jobId can't be found 
	 */
	public String getJobStatusMessage(String jobId) throws Exception {
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
				"	  \n" +
				"	select distinct ?statusMessage where {  \n" +
				"	   ?Job a job:Job.  \n" +
				"	   ?Job job:id '%s'^^XMLSchema:string .  \n" +
				"	   ?Job job:statusMessage ?statusMessage .  \n" +
				"	}",
				SparqlToXUtils.safeSparqlString(jobId));

		endpoint.executeQuery(query, SparqlResultTypes.TABLE);

		String trList[] = endpoint.getStringResultsColumn("statusMessage");

		if (trList.length > 1) {
			throw new Exception(String.format("Job %s has %d statusMessage entries.  Expecting 1.", jobId, trList.length));
		} else if (trList.length == 0) {
			if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find status message for Job %s",  jobId));
	    	}
		} else {
			return trList[0];
		}
	}

	/**
	 * Set job percent complete to 100, 
	 *   creating it if it doesn't exist.
	 * @param jobId
	 * @throws Exception
	 */
	public void setJobSuccess(String jobId) throws Exception {
		setJobSuccess(jobId, "");
	}
		
	public void setJobSuccess(String jobId, String statusMessage) throws Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
	    
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				" \n" +
				"DELETE {\n" +
				"   ?Job job:percentComplete ?percentComplete . \n" +
				"   ?Job job:statusMessage ?statusMessage . \n" +
				"   ?Job job:status ?status." +
				"} \n" +
				"INSERT {\n" +
				"   ?Job job:percentComplete '100'^^XMLSchema:integer.  \n" +
				"   ?Job job:statusMessage '%s'^^XMLSchema:string. \n" +
				"   ?Job job:status job:Success. \n" +
				"} \n" +
				"where { \n" +
				"   ?Job a job:Job. \n" +
				"   ?Job job:id '%s'^^XMLSchema:string . \n" +
				"   optional {?Job job:percentComplete ?percentComplete .} \n" +
				"   optional {?Job job:statusMessage ?statusMessage.} \n" +
				"   optional {?Job job:status ?status.} \n" +
				"}",

				SparqlToXUtils.safeSparqlString(statusMessage), SparqlToXUtils.safeSparqlString(jobId));
		// LocalLogger.logToStdErr(query);
		try {
			endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
		} catch (Exception e) {
			throw new Exception(e.getMessage());
		}
	}

	
	/**
	 * Set the results URL for a job,
	 *    creating it if it doesn't exist.
	 * @param jobId
	 * @param fullResultsURL
	 * @throws Exception
	 */
	public void setJobResultsURL(String jobId, URL fullResultsURL) throws Exception {
		
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
		
		URL sampleResultsURL = null;	// temporary measure to disable sample while not changing SPARQL query.  Matching functionality of removed utility method. 
		String uriFullURL = "URL_" + UUID.randomUUID().toString();
		String uriSampleURL = "URL_" + UUID.randomUUID().toString();

		String query = String.format("  \n" +
		        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
		        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
		        " \n" +
		        "DELETE { \n" +
		        "   ?Job job:fullResultsURL ?fullURI. \n" +
		        "   ?fullURI job:full ?fullURL .  \n" +
		        "   ?Job job:sampleResultsURL ?sampleURI. \n" +
		        "   ?sampleURI job:full ?sampleURL . \n" +
		        "} \n" +
		        "INSERT { \n" +
		        "   ?Job job:fullResultsURL <%s>. \n" +
		        "   <%s> job:full '%s'^^XMLSchema:string .  \n" +
		        "   ?Job job:sampleResultsURL <%s>. \n" +
		        "   <%s> job:full '%s'^^XMLSchema:string . \n" +
		        "} \n" +
		        "where { \n" +
		        "   ?Job a job:Job. \n" +
		        "   ?Job job:id '%s'^^XMLSchema:string . \n" +
		        "   optional {?Job job:fullResultsURL ?fullURI. \n" +
		        "             ?fullURI job:full ?fullURL . } \n" +
		        "   optional {?Job job:sampleResultsURL ?sampleURI. \n" +
		        "             ?sampleURI job:full ?sampleURL . } \n" +
		        "}",
		        uriFullURL, 
		        uriFullURL, 
		        SparqlToXUtils.safeSparqlString(fullResultsURL.toString()), 
		        uriSampleURL, 
		        uriSampleURL, 
		        ((sampleResultsURL != null) ? SparqlToXUtils.safeSparqlString(sampleResultsURL.toString()) : ""), 
		        SparqlToXUtils.safeSparqlString(jobId));
		// LocalLogger.logToStdErr(query);
		try {
			endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
		} catch (Exception e) {
			throw new Exception(e.getMessage());
		}
	}

	/**
	 * Get a jobId's full results URL
	 * @param jobId
	 * @return URL which could be null
	 * @throws Exception if jobId can't be found or it doesn't have exactly one full URL
	 */
	public URL getFullResultsURL(String jobId) throws Exception {	 
		String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	select distinct ?fullUrl where {  \n" +
	    	"	   ?Job a job:Job.  \n" +
	    	"	   ?Job job:id '%s'^^XMLSchema:string.  \n" +
	    	"	   ?Job job:fullResultsURL ?URL.  \n" +
	    	"      ?URL job:full ?fullUrl . \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

	    endpoint.executeQuery(query, SparqlResultTypes.TABLE);
	    
	    String trList[] = endpoint.getStringResultsColumn("fullUrl");
	    
	    if (trList.length > 1) {
	    	throw new Exception(String.format("Job %s has %d full restults URL entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find full URL for Job %s",  jobId));
	    	}
	    } else if (trList[0].equals("")) {
	    	return null;
	    } else {
	    	return new URL(trList[0]);
	    }
	}
	
	/**
	 * Get a jobId's full results URL
	 * @param jobId
	 * @return URL which could be null
	 * @throws Exception if jobID can't be found or it doesn't have exactly one sample URL
	 */
	public URL getSampleResultsURL(String jobId) throws Exception {	 
		String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#>  \n" +
	    	"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#>  \n" +
	    	"	  \n" +
	    	"	select distinct ?sampleUrl where {  \n" +
	    	"	   ?Job a job:Job.  \n" +
	    	"	   ?Job job:id '%s'^^XMLSchema:string.  \n" +
	    	"	   ?Job job:sampleResultsURL ?URL.  \n" +
	    	"      ?URL job:full ?sampleUrl . \n" +
	    	"	}",
	    	SparqlToXUtils.safeSparqlString(jobId));

	    endpoint.executeQuery(query, SparqlResultTypes.TABLE);
	    
	    String trList[] = endpoint.getStringResultsColumn("sampleUrl");
	    
	    if (trList.length > 1) {
	    	throw new Exception(String.format("Job %s has %d full restults URL entries.  Expecting 1.", jobId, trList.length));
	    } else if (trList.length == 0) {
	    	if (! this.jobExists(jobId) ) {
	    		throw new Exception(String.format("Can't find Job %s", jobId));
	    	} else {
	    		throw new Exception(String.format("Can't find sample URL for Job %s",  jobId));
	    	}
	    } else if (trList[0].equals("")) {
	    	return null;
	    } else {
	    	return new URL(trList[0]);
	    }
	}
	
	/**
	 * Create a Job with given jobId.  
	 * @param jobId
	 * @throws Exception
	 */
	public void createJob(String jobId) throws Exception {	
		// Note: createJob can be called by two different threads colliding on the same JobId without bad consequences.
	    
		// Testing only
		LocalLogger.logToStdOut("creating job " + jobId + " principal.user_name=" + ThreadAuthenticator.getThreadUserName());
		
		// get the current date and time...
		DateFormat xsdFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
		Calendar cal = Calendar.getInstance();

		Date initialDate = cal.getTime();
		
		// Caller must first ensure that job doesn't exist
		
		String jobUri = this.getJobUri(jobId);
		
	    String query = String.format("  \n" +
	        "prefix job:<http://research.ge.com/semtk/services/job#> \n" +
	        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
	        " \n" +
	        "INSERT  {\n" +
	        "<%s> a job:Job. \n" + 
	        "<%s> job:id '%s'^^XMLSchema:string. \n" +
	        "<%s> job:percentComplete '0'^^XMLSchema:integer. \n" +
	        "<%s> job:creationTime '%s'^^XMLSchema:dateTime. \n" +
	        "}",
	        jobUri, jobUri, SparqlToXUtils.safeSparqlString(jobId), jobUri, jobUri, xsdFormat.format(initialDate));
	    // LocalLogger.logToStdErr(query);
	    try {
	    	endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.getMessage());
	    }
	}

	public void addBinaryFile(String jobId, String fileId, String filename, String path) throws Exception {
		if (! this.jobExists(jobId)) {
	    	this.createJob(jobId);
	    }
		
		String jobUri = this.getJobUri(jobId);
		String fileUri = this.getFileUri(fileId);
		
		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
				"prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				" \n" +
				"INSERT  {\n" +
				"<%s> a job:BinaryFile. \n" + 
				"<%s> job:file <%s>. \n" +
				"<%s> job:fileID   '%s'^^XMLSchema:string. \n" +
				"<%s> job:filename '%s'^^XMLSchema:string. \n" +
				"<%s> job:path     '%s'^^XMLSchema:string. \n" +
				"}",
				fileUri, 
				jobUri, fileUri,
				fileUri, fileId,
				fileUri, filename,
				fileUri, path
				);
	    try {
	    	endpoint.executeQuery(query, SparqlResultTypes.CONFIRM);
	    } catch (Exception e) {
	    	throw new Exception(e.getMessage());
	    }
	}
	
	/**
	 * Get info about a file
	 * @param jobId
	 * @return
	 * @throws Exception
	 */
	public JobFileInfo getFile(String fileId) throws Exception {
		// get nodegroup
		JSONObject jObj = Utility.getResourceAsJson(this, "/nodegroups/job_get_file.json");
		SparqlGraphJson sgj = new SparqlGraphJson(jObj);
		NodeGroup ng = sgj.getNodeGroup();
		
		// set constraint
		PropertyItem fileIdProp = ng.getPropertyItemBySparqlID("fileID");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(fileId);
		fileIdProp.setValueConstraint(new ValueConstraint(ValueConstraint.buildValuesConstraint(fileIdProp, valList)));
		
		// run query
		String query = ng.generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, -1, null);
		TableResultSet res = null;
		try {
			res = (TableResultSet) endpoint.executeQueryAndBuildResultSet(query, SparqlResultTypes.TABLE);
	    } catch (Exception e) {
	    	throw new Exception(e.getMessage());
	    }
		Table table = res.getTable();
		if (table.getNumRows() < 1) { throw new Exception("Could not find file: " + fileId); }
		if (table.getNumRows() > 1) { throw new Exception("Found more than one file with fileId: " + fileId); }
		
		// set results
		JobFileInfo ret = new JobFileInfo();
		ret.setFileId(fileId);
		ret.setFileName(table.getCell(0, "filename"));
		ret.setUserName(table.getCell(0, "userName"));
		ret.setPath(table.getCell(0, "path"));
		return ret;
	}
	
	/**
	 * Delete jobs and their file paths before a given date
	 * @param boundaryDate
	 * @throws Exception
	 */
	public void deleteJobsAndFiles(Date boundaryDate) throws Exception {
		
		// get both nodegroups
		SparqlGraphJson sgjJobDeletion = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_deletion.json"));
		NodeGroup ngJobDel = sgjJobDeletion.getNodeGroup();
		SparqlGraphJson sgjGetPaths = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_file_info.json"));
		NodeGroup ngGetPaths = sgjGetPaths.getNodeGroup();
		
		// add creationTime constraint to each
		PropertyItem creationTime = ngJobDel.getPropertyItemBySparqlID("creationTime");
		String laterThanConstraint = ValueConstraint.buildFilterConstraint(creationTime, "<", boundaryDate);	
		creationTime.setValueConstraint(new ValueConstraint(laterThanConstraint));
		
		creationTime = ngGetPaths.getPropertyItemBySparqlID("creationTime");
		laterThanConstraint = ValueConstraint.buildFilterConstraint(creationTime, "<", boundaryDate);	
		creationTime.setValueConstraint(new ValueConstraint(laterThanConstraint));
		
		// delete files
		String query = ngGetPaths.generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, -1, null);
		Table pathTable = endpoint.executeQueryToTable(query);
		String paths[] = pathTable.getColumn("path");
		for (String p : paths) {
			File f = new File(p);
			if (f.exists()) {
				f.delete();
			}
		}
		
		// delete from triplestore
		query = ngJobDel.generateSparqlDelete(null);
		endpoint.executeQueryAndConfirm(query);
		
	}
	
	/**
	 * Delete jobs and their file paths before a given date
	 * @param boundaryDate
	 * @throws Exception
	 */
	public void deleteJob(String jobId) throws Exception {
		
		// delete files
		ArrayList<JobFileInfo> fileInfoList = this.getJobFiles(jobId);
		
		for (JobFileInfo info : fileInfoList) {
			File f = new File(info.getPath());
			if (f.exists()) {
				f.delete();
			}
		}
		
		// get job deletion nodegroup
		SparqlGraphJson sgjJobDeletion = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_deletion.json"));
		NodeGroup ngJobDel = sgjJobDeletion.getNodeGroup();
		
		// add id constraint
		PropertyItem idItem = ngJobDel.getPropertyItemBySparqlID("id");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(SparqlToXUtils.safeSparqlString(jobId));
		String jobIdConstraint = ValueConstraint.buildValuesConstraint(idItem, valList);	
		idItem.setValueConstraint(new ValueConstraint(jobIdConstraint));
		
		// delete from triplestore
		endpoint.executeQueryAndConfirm(ngJobDel.generateSparqlDelete(null));
		
	}
	
	public ArrayList<JobFileInfo> getJobFiles(String jobId) throws Exception {
		ArrayList<JobFileInfo> ret = new ArrayList<JobFileInfo>();
		
		// get nodegroup
		SparqlGraphJson sgjGetPaths = new SparqlGraphJson(Utility.getResourceAsJson(this, "/nodegroups/job_get_file_info.json"));
		NodeGroup ngGetPaths = sgjGetPaths.getNodeGroup();
		
		// set id constraint
		PropertyItem idItem = ngGetPaths.getPropertyItemBySparqlID("id");
		ArrayList<String> valList = new ArrayList<String>();
		valList.add(SparqlToXUtils.safeSparqlString(jobId));
		String jobIdConstraint = ValueConstraint.buildValuesConstraint(idItem, valList);	
		idItem.setValueConstraint(new ValueConstraint(jobIdConstraint));
		
		// run query
		String query = ngGetPaths.generateSparql(AutoGeneratedQueryTypes.QUERY_DISTINCT, false, -1, null);
		Table pathTable = endpoint.executeQueryToTable(query);
		
		// change results into JobFileInfo objects
		for (int i=0; i < pathTable.getNumRows(); i++) {
			JobFileInfo info = new JobFileInfo();
			info.setFileId(pathTable.getCell(i, "fileID"));
			info.setFileName(pathTable.getCell(i, "filename"));
			info.setPath(pathTable.getCell(i, "path"));
			info.setUserName(pathTable.getCell(i, "userName"));
			ret.add(info);
		}
		
		return ret;
	}
	
	/**
	 * Does jobId exist
	 * @param jobId
	 * @return true if job with jobId exists
	 * @throws Exception
	 */
	public boolean jobExists(String jobId) throws Exception {

		String query = String.format("  \n" +
				"prefix job:<http://research.ge.com/semtk/services/job#> \n" +
		        "prefix XMLSchema:<http://www.w3.org/2001/XMLSchema#> \n" +
				"SELECT count(?Job) \n" +
				"where { \n" +
				"   ?Job a job:Job. \n" +
				"   ?Job job:id ?id. \n" +
				"      VALUES ?id { '%s'^^XMLSchema:string }. \n" +
				"}",
				SparqlToXUtils.safeSparqlString(jobId));
		
		// LocalLogger.logToStdErr(query);
		try {
			endpoint.executeQuery(query, SparqlResultTypes.TABLE);
		    String trList[] = endpoint.getStringResultsColumn("callret-0");
		    if (trList.length == 1) {
		    	if (trList[0].equals("1")) { 
		    		return true; 
		    	} else if (trList[0].equals("0")) { 
		    		return false; 
		    	} else {
		    		throw new Exception (String.format("Found %s jobs with jobId=%s", trList[0], jobId));
		    	}
		    } else {
	    		throw new Exception (String.format("Error processing results of count query for jobId=%s.  %d rows returned.", jobId, trList.length));
		    }

		} catch (Exception e) {
			throw new Exception(e.getMessage());
		}
	}

	/**
	 * Return when job with given jobId is at least percentComplete % complete
	 * @param jobId
	 * @param percentComplete
	 * @param maxWaitMsec
	 * @throws Exception if maxWaitMsec milliseconds pass without a return
	 */
	public void waitForPercentComplete(String jobId, int percentComplete, int maxWaitMsec) throws Exception {
		int totalMsec = 0;
		int sleepMsec = 0;
		
		// wait maximum of this.prop.jobMaxWatiMsec
		while (totalMsec < maxWaitMsec) {
			if (this.getJobPercentComplete(jobId) >= percentComplete) {
				return;
			}
			// wait 1/4 seconds longer each time until 3 seconds
			if (sleepMsec < 3000) {
				sleepMsec += 250;
			}
			Thread.sleep(sleepMsec);
			totalMsec += sleepMsec;
		}
		throw new Exception(String.format("Maximum wait time of %d Msec has passed without job %s reaching %d percent complete.", maxWaitMsec, jobId, percentComplete));
	}
	
	/**
	 * Return when job is at least percentComplete complete or maxWaitMse have expired
	 * @param jobId
	 * @param percentComplete
	 * @param maxWaitMsec
	 * @returns percent complete
	 * @throws Exception on error
	 */
	public int waitForPercentOrMsec(String jobId, int percentComplete, int maxWaitMsec) throws Exception {
		long sleepMsec = 200;
		int actualPercent = 0;
		long now = System.currentTimeMillis();
		long endTime = now + maxWaitMsec;
		
		now -= 1; // make sure we run the loop at least once
		
		while (now < endTime) {
			actualPercent = this.getJobPercentComplete(jobId);
			if (actualPercent >= percentComplete) {
				break;
			}
			
			// wait 1.3x seconds longer each time until 3 seconds
			if (sleepMsec < 3000) {
				sleepMsec = Math.round(sleepMsec * 1.3);
			}
			
			// don't wait past projected end time
			now = System.currentTimeMillis();
			sleepMsec = Math.min(sleepMsec, (endTime - now) );
			
			if (sleepMsec > 0) {
				Thread.sleep(sleepMsec);
				now = System.currentTimeMillis();
			}
		}
		return actualPercent;
	}
}
